#!/bin/bash -e

# Adapted from http://lartc.org/wondershaper/

DEV=$1
DOWNLINK=$2
UPLINK=$3

# The following fudge factors allow you to express the usable % of your link.  
#
# Experimentation has shown that ~75% of the author's ADSL downlink can be used 
# before upstream congestion starts to affect round-trip times. In other words, 
# by throttling our download speeds we can ensure that our ISP does not queue 
# any packs on our behalf, giving us full control over congestion.
DOWNFACTOR='74/100'
UPFACTOR='75/100'

if [ "x$DEV" = "x" ]
then
    echo "Usage: $0 (DEV) [ 'clear' | (DOWNLINK kbit/s) (UPLINK kbit/s) ]"
    exit 0
fi

# Display status when DOWNLINK/UPLINK are ommitted
if [ "x$DOWNLINK" = "x" ]
then
    #echo "--------------------------------------------------------------------------------"
    #iptables -nvL -t mangle
    #echo "--------------------------------------------------------------------------------"
    tc -s filter ls dev $DEV
    echo "--------------------------------------------------------------------------------"
    #tc -s qdisc ls dev $DEV
    #echo "--------------------------------------------------------------------------------"
    tc -s class ls dev $DEV
    exit 0
fi

# Clear both IN and OUT
tc qdisc del dev $DEV root    2> /dev/null > /dev/null || true
tc qdisc del dev $DEV ingress 2> /dev/null > /dev/null || true

# Flush and delete all mangle rules
iptables -F 
iptables -X 
iptables -t mangle -F 
iptables -t mangle -X 

if [ "x$DOWNLINK" = "xclear" ]
then
    echo "Cleared traffic rules on $DEV"
    exit 0
fi

trap "$0 $1 clear" ERR

# Calculations
#
# Target latency is < 50ms. This means max burst length should be limited to 
# 1/20th the queue's rate.


LOCALIP=$(ifconfig eth0 | sed -ne 's/^.*inet addr:\([0-9.]\+\).*/\1/p')

# =============================================================================
# Queues and Classes
# =============================================================================
# 1: ROOT
# |-- 1:ff LOCAL_TRAFFIC (to/from this host itself)
# | `-- ff: (sfq)
# |-- 1:1 INTERNET->LAN (downlink)
# | `-- 10: (red) Drop traffic as link approaches congestion
# `-- 1:2 LAN->INTERNET (uplink)
#   |-- 1:21: High priority
#   | `-- 21: (sfq)
#   |-- 1:22: Medium priority
#   | `-- 22: (sfq)
#   `-- 1:23: Low priority
#     `-- 23: (sfq) Low priority

# ROOT
tc qdisc add dev $DEV root handle 1: htb

    # LOCAL TRAFFIC
    tc class add dev $DEV parent 1: classid 1:ff htb \
        rate 100mbit \
        burst $((100/20))mbit \
        cburst $((100/20))mbit \
        prio 1

        # .. and its actual queue that holds the packets
		tc qdisc add dev $DEV parent 1:ff handle ff: sfq perturb 10

    # INTERNET->LAN (downlink)
    #
    # NOTES: Target is 50s (1/20th of a second), so our burst and min sizes 
    # must be smaller than this or we're too late to influence latency.  I've 
    # chosen to use 1/40th as the lower bound.
    tc class add dev $DEV parent 1: classid 1:1 htb \
        rate $(($DOWNLINK*$DOWNFACTOR))kbit \
        ceil $(($DOWNLINK*$DOWNFACTOR))kbit \
        burst $(($DOWNLINK*$DOWNFACTOR/40))kbit \
        cburst 1500 \
        prio 10

        # .. and its actual queue that holds the packets
        # Note: All values are in BYTES. It doesn't seem to accept "kbit"
        #
        # The burst calculation needs to be increased by one so as to avoid an 
        # internal assert in the qdisc (seems our target and their min 
        # acceptable burst are one and the same)
        tc qdisc add dev $DEV parent 1:1 handle 10: red \
            limit $(($DOWNLINK*$DOWNFACTOR*1000/8)) \
            avpkt 1500 \
            burst $((($DOWNLINK*1000/8/40/1500)+1)) \
            min   $(($DOWNLINK*1000/8/40)) \
            max   $(($DOWNLINK*1000/8/20)) \
            probability 1

    # LAN->INTERNET (uplink)
    tc class add dev $DEV parent 1: classid 1:2 htb \
        rate $(($UPLINK*$UPFACTOR))kbit \
        ceil $(($UPLINK*$UPFACTOR))kbit \
        burst $(($UPLINK/20))kbit \
        cburst $(($UPLINK/20))kbit \
        prio 20

        # High priority
        tc class add dev $DEV parent 1:2 classid 1:21 htb \
            rate $(($UPLINK*$UPFACTOR*4/6))kbit \
            ceil $(($UPLINK*$UPFACTOR))kbit \
            prio 0

        # Medium priority
        tc class add dev $DEV parent 1:2 classid 1:22 htb \
            rate $(($UPLINK*$UPFACTOR*2/6))kbit \
            ceil $(($UPLINK*$UPFACTOR))kbit \
            prio 1

        # Low priority
        tc class add dev $DEV parent 1:2 classid 1:23 htb \
            rate $(($UPLINK*$UPFACTOR*1/6))kbit \
            prio 2

        # .. and their actual queues that hold the packets
        for ID in 21 22 23
        do
            tc qdisc add dev $DEV parent 1:$ID handle $ID: sfq
            ## tc qdisc add dev $DEV parent 1:$ID handle $ID: red \
            ##     limit $(($UPLINK*$UPFACTOR*1000/8)) \
            ##     avpkt 1500 \
            ##     burst $((($UPLINK*1000/8/20/1500)+1)) \
            ##     min   $(($UPLINK*1000/8/20)) \
            ##     max   $(($UPLINK*$UPFACTOR*1000/8)) \
            ##     ecn \
            ##     probability 1
        done


# =============================================================================
# Filters
# =============================================================================

# -----------------------------------------------------------------------------
# LOCAL TRAFFIC
# Mark traffic generated by this host itself (INPUT + OUTPUT, but not FORWARD)
iptables -t mangle -A INPUT  -p all -i $DEV -j MARK --set-mark 0xff
iptables -t mangle -A OUTPUT -p all -o $DEV -j MARK --set-mark 0xff

# ("fw" means the handle refers to a MARK, rather than a qdisc)
tc filter add dev $DEV parent 1: protocol ip prio 1 handle 0xff fw classid 1:ff

# -----------------------------------------------------------------------------
# INTERNET->LAN (downlink)
#
# Note: We assume that LAN->LAN traffic is *not* forwarded through this host, 
# and so we need only check the destination of a given packet. We've already 
# taken care of this host's own traffic above.

iptables -t mangle -N DOWNLINK
iptables -t mangle -A DOWNLINK -p all -j MARK --set-mark 0x1
tc filter add dev $DEV parent 1: protocol ip prio 2 handle 0x1 fw classid 1:1

for SUBNET in 192.168.0.0/16 10.0.0.0/8 172.16.0.0/12 
do
    iptables -t mangle -A PREROUTING -p all -i $DEV ! -s $SUBNET -d $SUBNET -j DOWNLINK
done


# -----------------------------------------------------------------------------
# LAN->INTERNET (uplink)
#
# Note: Assumes that all downlink and private traffic have already been 
# classified, so no source checks are performed.

iptables -t mangle -N UPLINK
iptables -t mangle -A UPLINK -p all -j MARK --set-mark 0x22     # Default to medium priority
#for CHAIN in PREROUTING INPUT FORWARD OUTPUT POSTROUTING DOWNLINK UPLINK
#do
#    iptables -t mangle -I $CHAIN -p tcp --sport 12345 -j MARK --set-mark 0/0
#    iptables -t mangle -I $CHAIN -p tcp --dport 12345 -j MARK --set-mark 0/0
#done

for SUBNET in 192.168.0.0/16 10.0.0.0/8 172.16.0.0/12 
do
    iptables -t mangle -A PREROUTING -p all -i $DEV -s $SUBNET ! -d $SUBNET -j UPLINK
done

##
## HIGH PRIORITY ##
##

# TOS Minimum Delay (ssh, NOT scp)
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip tos 0x10 0xff \
    flowid 1:21

# ICMP (ip protocol 1) in the interactive class so we can do measurements & 
# impress our friends:
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip protocol 1 0xff \
    flowid 1:21

# Prioritize small packets (<64 bytes)
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip protocol 6 0xff \
    match u8 0x05 0x0f at 0 \
    match u16 0x0000 0xffc0 at 2 \
    flowid 1:21

# Prioritise ACK packets (but only if they are small)
# IP protocol 6,
# IP header length 0x5(32 bit words),
# IP Total length 0x34 (ACK + 12 bytes of TCP options)
# TCP ack set (bit 5, offset 33)
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip protocol 6 0xff \
    match u8 0x05 0x0f at 0 \
    match u16 0x0000 0xffc0 at 2 \
    match u8 0x10 0xff at 33 \
    flowid 1:21

# Traffic headed to robmeerman.co.uk (typically SSH proxying to else where)
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip dst 85.119.82.218/32 \
    flowid 1:21

# Traffic originating from the Xbox should be treated as urgent
tc filter add dev $DEV parent 1: protocol ip prio 20 u32 \
    match ip src 192.168.1.2/32 \
    flowid 1:21


##
## LOW PRIORITY ##
##

# # WiiU, while it's downloading purchases
# tc filter add dev $DEV parent 1: protocol ip prio 30 u32 \
#     match ip src 192.168.1.5/32 \
#     flowid 1:23

# TOS High Throughput
tc filter add dev $DEV parent 1: protocol ip prio 30 u32 \
    match ip tos 0x8 0xff \
    flowid 1:23

# If no other filter has classified the packet, then use FW markers (set by 
# iptables -j MARK). All UPLINK packets are marked as 0x22 by default (see 
# iptables command earlier)
tc filter add dev $DEV parent 1: protocol ip prio 40 handle 0x21 fw classid 1:21 # High priority
tc filter add dev $DEV parent 1: protocol ip prio 40 handle 0x22 fw classid 1:22 # Medium priority
tc filter add dev $DEV parent 1: protocol ip prio 40 handle 0x23 fw classid 1:23 # Low priority


# Reset counters, so that packet counts are in sync (it takes time to add 
# rules, and during that time the first rule added may be hit, leading to 
# confusing packet counts: "But these rules should always apply to the same 
# packets! How can their hit count be different?"
iptables -t mangle -Z
